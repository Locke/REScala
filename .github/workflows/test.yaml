name: test

on:
  push:
  pull_request:
  workflow_dispatch:
    inputs:
      ref:
        description: 'checkout reference (sha/branch)'
        required: false
        type: string

jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [macOS-12, ubuntu-22.04, windows-2022]
        java-version: [11, 17, 20]
    env:
      JAVA_OPTS: -Xmx4g
    steps:
    - uses: actions/checkout@v3
    - uses: coursier/cache-action@v6
      continue-on-error: true
    - uses: actions/setup-java@v3
      with:
        java-version: ${{ matrix.java-version}}
        distribution: 'zulu'
    - uses: actions/setup-node@v3
      with:
        node-version: '18'
    - name: install jsdom
      run: npm install jsdom

    - name: Run tests
      continue-on-error: true
      run: |
        sbt "set ThisBuild / Test / parallelExecution := false" compile Test/compile testQuick

      # the idea here is, that we first do compile, Test / compile, testQuick sequentially, so if compilation fails on some sub project we abort early without half starting tests on some other sub project. However, sometimes compilation or testing fails spuriously, so we just do it again, which should fix most of the spurious compilation failures, and also may try to reexecute some of the spurious tests. As this keeps the incremental sbt cache, if the first one succeeds, the second one should be essentially for free.
    - name: Run tests again for added reliability
      run: |
        sbt "set ThisBuild / Test / parallelExecution := false" compile Test/compile testQuick
